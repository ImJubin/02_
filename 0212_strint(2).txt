패턴 매칭

♡패턴 매칭에 사용되는 알고리즘들

• 고지식한 패턴 검색 알고리즘
• 카프-라빈 알고리즘
• KMP 알고리즘
• 보이어-무어 알고리즘

패턴 매칭

♡고지식한 알고리즘(Brute Force)
• 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴
내의 문자들을 일일이 비교하는 방식으로 동작
(예시그림참조)

i = j = 0
while i < N and j < M 		# i와 j가 내부에 있을때
	if t[i] != t[j]
		i = i -j + 1
		j = 0

	else:				#같으면
		i += 1
		j += 1

if j == M
	return i-M 			#시작위치
else:
	return -1

-----------------------------------------------------------
def pattern_count(p, t):        # 패턴의 등장 횟수 리턴
    N = len(t)
    M = len(p)
    i = j = 0
    cnt = 0
    while i < N:
        if t[i] != p[j]:        # 다르면
            i = i - j + 1       # i - j 비교를 시작했던 위치
            j = 0
        else:                   # 같으면
            i += 1
            j += 1
        if j==M:                # 패턴을 찾은 경우
            cnt += 1
            i = i - j + 1
            j = 0

    if j==M:
        return i-j              # 패턴의 시작 인덱스
    else:
        return -1               # 패턴이 없는 경우

t = 'TTTTATTAATA'
p = 'TTA'


print(pattern_count(p, t))
---------------------------------------------------------------

♡ 고지식한 패턴 검색 알고리즘의 시간 복잡도
• 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로
O(MN)이 됨 (** m-n번 돌아감,,, 거의 n번)
• 길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약
10,000*80 = 800,000 번의 비교가 일어난다.
• 비교횟수를 줄일 수 있는 방법은 없는가?

(*저 복잡도 형태가 문제에 나올 듯. kmp , 보이어가 최악의 경우 더 오래걸림.)

♡불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를
미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시
비교하지 않고 매칭을 수행

♡패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
• next[M] : 불일치가 발생했을 경우 이동할 다음 위치

♡시간 복잡도 : O(M+N)

♡ 아이디어 설명
• 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨
앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다
• 실패한 텍스트 문자와 P[4]를 비교한다

T[ ]	ㅁㅁㅁㅁㅁabcdabcdㅁㅁㅁㅁㅁ
		  P[ ]abcdabcef
			      abcdeabcef
a 전까지. 이만큼 shift
				   d 여기서부터 비교 시작


♡ 매칭이 실패했을 때 돌아갈 곳을 계산한다.
앞의 예에서 e와 매칭이 실패 했고
이때 돌아갈 곳의 계산 값은 3로
문자 d의 위치를 의미한다.

	-1 0 0 0 0  1 2 3 0 0

j=f이니?
j=0
j=1
j=2
j=3
...
j=0



보이어-무어 알고리즘

♡오른쪽에서 왼쪽으로 비교
♡대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
♡보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하고
이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이
만큼이 된다. (*좀 더 많이 건너 뛸 거다)

(예시그림참고.p.48~50)

♡ 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우

패턴에서 같은 문차 찾아 세칸을 점프!

♡문자열 매칭 알고리즘 비교

• 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
• 고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)
• 카프-라빈 알고리즘 : 수행시간 ⊙(n)
• KMP 알고리즘 : 수행시간 ⊙(n)

• 보이어-무어 알고리즘
- 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열위 문자를 적어도 한번씩
훑는다는 것이다. 따라서 최선의 경우에도 Ω(n) (* O(n)은 최악의 경우 이만큼까지,,, 저 경우는 잘 해도 오메가만큼이란 얘기)

- 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다
- 발상의 전환 : 패턴의 오른쪽부터 비교한다
- 최악의 경우 수행시간 : O(mn)
- 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다


<연습문제3>
♡ 고지식한 방법을 이용하여 패턴을 찾아 봅시다.

♡ 결과 값으로 찾은 위치 값을 결과로 출력합니다.

#5356.의석이의 세로로 말해요
      0123	0123 456 789 10
A = 'XYPV' 	XEYOPGVGXYPUSY'
		A[0]B[0]A[i]B[i] ...
		i = j = 0

ans = ' '
i = 0
j = 0
k = 0
while i+j < N+M:
if i<N
ans += A[i]
i +=j
if i < N
ans += A[j]
j += 1




B = 'EOGGXYPVSY'

--------------------------------------------------------------------------------
t = 'TTTTTATTAATA'
p = 'TTA'
N = len(t)
M = len(p)
def search(p, t):
    N = len(t)
    M = len(p)
    for i in range(N-M+1):      # t에서 패턴을 비교할 시작 위치 인덱스
        for j in range(M):          # p에서 비교할 위치 인덱스
            if t[i+j]!=p[j]:
                break
        else:                   # break에 걸리지 않고 for가 끝난 경우 실행
            return i            # 패턴이 처음 나나타난 인덱스 리턴
    return -1                   # T에 P 패턴이 없는 경우

print(search(p, t))


-----------------------------------------------------------------------------------

문자열 암호화 문자열 압축<참고>

시저암호<참고>
pass


------------------------------------------------------------------------------------
1 고지식
2 kmp
3 보이어무어
아이디어소개 >>  cs 아이디어설명 목표

패턴...

보이어무어

AAACD
AAC

뒤부터 찾기
최대한땡겨야하기때문
기준점은 위아래 둔다

DEFCD
AAC

보이어
최선 : 맨 뒤부터 찾았을 때처음부터 틀려버리고, 등장안했을때 건너뛰어버림(위경우)
최악 :  찾는 로직 들어가 버려서 더 느려짐.(밑경우)

AAAAA
AAC


KMP

A B C D A B C D A B E E
A B C D A B C E
-----------------

접두사 접미사 비교

일치되는 구간만큼 건너뜀
ㅁㅁ
ㅁㅁㅁ
ㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁㅁㅁ
....
각 패턴 별로 접두사 접미사를 비교하고,, 일치되는 구간만큼,,,

pi배열 짜기 ....(모두 다 하면 오버헤드가 됨)
따라서 평균치로 잡음.

1. IM

2. DFS --- BFS >>> ,,,, ㅠㅠ

1. IM 두개의 탑쌓기
각탑의 높이에 맞춰 화물들을 쌓았을 때
최소 비용이 들도록 계산하시오


ㅁㅁㅁㅁㅁ
1 5 10 9 7

ㅡㅡㅡㅡㅡㅡ				3M
ㅡㅡㅡㅡㅡㅡ				2M
ㅡㅡㅡㅡㅡㅡ 	1층일때, 무게 M *1
ㅡ          ㅡ
(3개)     (2개)
-----------------
2개의 지지대

첫줄은 화물수 , 첫째탑의 수, 둘째탑의 수
둘째줄은 각 화물 쌓은 수
5 3 2
1 2 3 4 5

무게 = M
층 = N
M,N = 입력값받기 ,,,
첫째탑의 수와 둘째탑의 수 차이가 제일 적어야 함
첫째탑 층수 =  
둘째탑 층수  =
그 둘의 차이 =



<풀이>
화물무게가 비용에 포함되어있나?


?????????????
------------------------------

k ------------1



---------------------------------

(무향 / 유향 /, 노드와 간선=엣지)

(행렬)
1 
2 
3 

(장점 : 탐색 시간 짧음, 인덱스를알고있기때문에 바로 탐색이들어감)
(단점 : 1이 얼마나 연결되어있니?? <노드의 수만큼 돌아야함
	  메모리많이씀,, 0이너무많아! >> 해당 노드수 대비 간선 수 많으면 = (연결관계 많으면) 행렬 선택.)

(리스트)
1 [2 3]
2 [1 4]
3 [1]
4 [2]

(장점 : 길이만큼 순차적으로탐색해야할수있음
	  메모리 덜씀)

즉, 노드수가 많으면 리스트 선택.

2. DFS --- BFS >>> ,,,, ㅠㅠ

스택
ㅁㅁㅁㅁㅁㅁㅁㅁ
1-2-6-8-3-4-5
DFS(깊이우선탐색)


큐
ㅁㅁㅁㅁㅁㅁㅁㅁ

1-2-3-4-8-4-5

BFS(너비우선)



1. 인접 리스트, 행
2. dfs > 스택 > 함수가 이미 되어있음
bfs > 큐 > 자료구조

dfs
1-2-6-
1
2
6

ㅁㅁㅁㅁㅁㅁㅁ
1 238 6 4 5

2

dfs와 bfs











































 













































