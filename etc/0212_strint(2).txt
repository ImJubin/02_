패턴 매칭

♡패턴 매칭에 사용되는 알고리즘들

• 고지식한 패턴 검색 알고리즘
• 카프-라빈 알고리즘
• KMP 알고리즘
• 보이어-무어 알고리즘

패턴 매칭

♡고지식한 알고리즘(Brute Force)
• 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴
내의 문자들을 일일이 비교하는 방식으로 동작
(예시그림참조)

i = j = 0
while i < N and j < M 		# i와 j가 내부에 있을때
	if t[i] != t[j]
		i = i -j + 1
		j = 0

	else:				#같으면
		i += 1
		j += 1

if j == M
	return i-M 			#시작위치
else:
	return -1

-----------------------------------------------------------
def pattern_count(p, t):        # 패턴의 등장 횟수 리턴
    N = len(t)
    M = len(p)
    i = j = 0
    cnt = 0
    while i < N:
        if t[i] != p[j]:        # 다르면
            i = i - j + 1       # i - j 비교를 시작했던 위치
            j = 0
        else:                   # 같으면
            i += 1
            j += 1
        if j==M:                # 패턴을 찾은 경우
            cnt += 1
            i = i - j + 1
            j = 0

    if j==M:
        return i-j              # 패턴의 시작 인덱스
    else:
        return -1               # 패턴이 없는 경우

t = 'TTTTATTAATA'
p = 'TTA'


print(pattern_count(p, t))
---------------------------------------------------------------

♡ 고지식한 패턴 검색 알고리즘의 시간 복잡도
• 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로
O(MN)이 됨
• 길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약
10,000*80 = 800,000 번의 비교가 일어난다.
• 비교횟수를 줄일 수 있는 방법은 없는가?

(*저 복잡도 형태가 문제에 나올 듯.)

♡불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를
미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시
비교하지 않고 매칭을 수행

♡패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
• next[M] : 불일치가 발생했을 경우 이동할 다음 위치

♡시간 복잡도 : O(M+N)

♡ 아이디어 설명
• 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨
앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다
• 실패한 텍스트 문자와 P[4]를 비교한다

T[ ]	ㅁㅁㅁㅁㅁabcdabcdㅁㅁㅁㅁㅁ
		  P[ ]abcdabcef
			      abcdeabcef
a 전까지. 이만큼 shift
				   d 여기서부터 비교 시작


♡ 매칭이 실패했을 때 돌아갈 곳을 계산한다.
앞의 예에서 e와 매칭이 실패 했고
이때 돌아갈 곳의 계산 값은 3로
문자 d의 위치를 의미한다.

	-1 0 0 0 0  1 2 3 0 0

j=f이니?
j=0
j=1
j=2
j=3
...
j=0



보이어-무어 알고리즘

♡오른쪽에서 왼쪽으로 비교
♡대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
♡보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하고
이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이
만큼이 된다. (*좀 더 많이 건너 뛸 거다)

(예시그림참고.p.48~50)

♡ 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우

패턴에서 같은 문차 찾아 세칸을 점프!

♡문자열 매칭 알고리즘 비교

• 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
• 고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)
• 카프-라빈 알고리즘 : 수행시간 ⊙(n)
• KMP 알고리즘 : 수행시간 ⊙(n)

• 보이어-무어 알고리즘
- 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열위 문자를 적어도 한번씩
훑는다는 것이다. 따라서 최선의 경우에도 Ω(n) (* O(n)은 최악의 경우 이만큼까지,,, 저 경우는 잘 해도 오메가만큼이란 얘기)

- 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다
- 발상의 전환 : 패턴의 오른쪽부터 비교한다
- 최악의 경우 수행시간 : O(mn)
- 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다


<연습문제3>
♡ 고지식한 방법을 이용하여 패턴을 찾아 봅시다.

♡ 결과 값으로 찾은 위치 값을 결과로 출력합니다.

#5356.의석이의 세로로 말해요

A = 'XYPV' 	XEYOPGVGXYPUSY'
		A[0]B[0]A[i]B[i] ...

B = 'EOGGXYPVSY'

--------------------------------------------------------------------------------
t = 'TTTTTATTAATA'
p = 'TTA'
N = len(t)
M = len(p)
def search(p, t):
    N = len(t)
    M = len(p)
    for i in range(N-M+1):      # t에서 패턴을 비교할 시작 위치 인덱스
        for j in range(M):          # p에서 비교할 위치 인덱스
            if t[i+j]!=p[j]:
                break
        else:                   # break에 걸리지 않고 for가 끝난 경우 실행
            return i            # 패턴이 처음 나나타난 인덱스 리턴
    return -1                   # T에 P 패턴이 없는 경우

print(search(p, t))


-----------------------------------------------------------------------------------

문자열 암호화 문자열 압축<참고>

시저암호<참고>
pass


	










































