0211_string


♡컴퓨터에서의 문자표현

• 글자 A를 메모리에 저장하는 방법에 대해서 생각해보자
• 물론 칼로 A라는 글자를 새기는 방식은 아닐 것이다. 메모리는 숫자만을
전장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는
방법을 사용하지 않는 한(이 방법은 메모리 낭비가 심하다) 각 문자에
대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이
사용될 것이다.
• 영어가 대소문자 합쳐서 52자 이므로 6(64가지)비트면 모두 표현할 수
이를 코드체계라고 한다.
- 000000 -> 'a', 000001 -> 'b'

♡ 그런데 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해
놓고 사용했지만
♡네트워크(인터넷 : 인터넷은 미국에서 발전했다)이 발전하면서 서로간에
정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.

♡그래서 혼동을 피하기 위해 표준안을 만들기로 했다.

♡바로 이러한 목적으로 1967년, 미국에서 ASCII(American Standard
Code for Information Interchange)라는 문자 인코딩 표준이
제정되었다.

♡ ASCII는 7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한
제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져
있다.

♡확장 아스키는 표준 문자 이외의 악셋트 문자, 도형 문자, 특수 문자,
특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
• 표준 아스키는 7-bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1Byte
내의 8-bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
• 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수
있도록 하고 있다. 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른
프로그램이나 컴퓨터 사이에 교환되지 못한다.
• 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서
세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는
프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.

♡유니코드도 다시 Character Set으로 분류된다.
· UCS-2(Universal Character Set 2)
· UCS-4(Universal Character Set 4)
• 유니코드를 저장하는 변수의 크기를 정의
• 그러나, 바이트 순서에 대해서 표준화하지 못했음.
• 다시 말해 파일을 인식 시 이 파일이 UCS-2, UCS-4인지 인식하고 각 경우를
구분해서 모두 다르게 구현해야 하는 문제 발생
• 그래서 유니 코드의 적당한 외부 인코딩이 필요하게 되었다.

(*주소가 1byte 단위로 부여)


big-endian, little-endian

♡유니코드 인코딩 (UTF : Unicode Transformation Format)

· UTF-8 (in web) (1~4 bytes, 가변적)

-MIN : 8t MAX: 32bit(1 Byte * 4)

· UTF-16 (in windows, java)	
-MIN : 16bit, MAX: 32bit(2 Byte * 2)

· UTF-32 (in unix)

-MIN : 32bit, MAX: 32bit(4 Byte * 1)


문자열

문자열의 분류

♡ java에서 String 클래스에 대한 메모리 배치 예
• 그림에서 보이듯, java.lang.String 클래스에는 기본적인 객체 메타 데이터 외에도 네
가지 필드들이 포함되어 있는데, hash값(hash), 문자열의길이(count), 문자열
데이터의 시작점(offset), 그리고 실제 문자열 배열에 대한 참조(value)이다.
(그림 참조)

♡ C언어에서 문자열 처리
• 문자열은 문자들의 배열 형태로 구현된 응용 자료형
• 문자배열에 문자열을 저장할 때는 항상 마지막에 끝을
표시하는 널문자('₩O)를 넣어줘야 한다.

char ary[ ]="abc"; // char ary[ ]={'a', 'b', 'c', 'W0'};

• 문자열 처리에 필요한 연산을 함수 형태로 제공한다.

strlen(, strcpy(), strcmp(), ...

♡ 다음 두 코드의 차이 이해하기
s1 = list(input())
s2 = input()
(실습파일 참조)

♡ Java(객체지향 언어)에서의 문자열 처리
• 문자열 데이터를 저장, 처리해주는 클래스를 제공한다.
• String클래스를 사용한다.

String str="abc"; //또는 String str = new String("abc")

• 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
+, length(), replace(), split(, substring(, ...
보다 풍부한 연산을 제공한다.


♡Python에서의 문자열 처리
• char 타입 없음
• 텍스트 데이터의 취급방법이 통일되어 있음

• 문자열 기호
'(홑따옴표), "(쌍따옴표), "(홑따옴표 3개), "' (쌍따옴표 3개)
+ 연결(Concatenation)
• 문자열 + 문자열 : 이어 붙여주는 역할

• 문자열 * 수 : 수만큼 문자열이 반복


♡ Python에서의 문자열 처리
• 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는
인덱싱, 슬라이싱 연산들을 사용할 수 있음

• 문자열 클래스에서 제공되는 메소드

replace(), split(, isalpha(), find0

• 문자열은 튜플과 같이 요소값을 변경 할 수 없음(immutable)


♡ ♡C와 Java의 String 처리의 기본적인 차이점

• c는 아스키 코드로 저장한다.
• java는 유니코드(UTF16, 2byte)로 저장한다.
• 파이썬은 유니코드(UTF8) 로 저장

C

char * name = 《홍길동";
int count = strlen(name);
printf("%d", count);
6이 출력된다.

Java

String name = "홍길동";
System.out.println(name.length());
3이 출력된다.

Python
name = "홍길동"
print(len(name))

3이 출력된다.

♡자기 문자열에서 뒤집는 방법이 있고 새로운 빈 문자열을
만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있겠다.

♡자기 문자열을 이용할 경우는 swap을 위한 임시 변수가
필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.
문자열 길이 9
9 / 2 = 4.5
4회 반복

(예시참고)

for i in range(N//2)
....

♡Python에서 문자열 뒤집기
Ex)

S = 'Reverse this strings' # 'sgnirts siht esreveR'

S = s[ :- 1]


s = 'abcd'

s = list(s)

s.reverse()

s = "join(s)

♡ for 문을 이용해 구현해봅시다.



<연습 문제2> 1215. [S/W 문제해결 기본] 3일차 - 회문1


4
CBBCBAAB
CCCBABCB
CAAAACAB
BACCCCAC
AABCBBAC
ACAACABC
BCCBAABC
ABBBCCAA

"기러기", "토마토", "스위스"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장
이나 낱말을 회문(回文, palindrome)이라 한다. 8x8 평면 글자판에서 제시된 길
이를 가진 회문의 개수를 구하라.


<풀이과정>

CBBCBAAB
	4567
	8-n 위치까지 변하면 됨.
	j+n-1
 BBCB
       4
for j : 0->8-n

n//2 만큼 비교

CBBC

k=0

for j : 0->8-n
	for k : 0->n//2-1
		if s[j+k] s[j+n-1-k]
	break
	(not,, +=1)
	if cnt == N//2	# 행운인 경우
		total += 1
else



for else 구문 활용하기

break

else
total += 1


연산

문자열 비교

♡c strcmp() 함수를 제공한다.
♡Java에서는 equals() 메소드를 제공한다.
• 문자열 비교에서 == 연산은 메모리 참조가 같은지를 묻는 것 # 메모리에서 같은 문자열을 참고 하고 있니?
♡파이썬에서는 == 연산자와 is 연산자를 제공한다.
• == 연산자는 내부적으로 특수 메서드 _eq_()를 호출	

[참고] s1과 나머지 문자열을 == , is로 비교한 결과를 확인해보세요.
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 =s1
s5 = s1[:2]+'c'

==와 is는 다름
--------------------------------------------
>>>>>실습
s1 = 'abc'
s2 = 'ab'
s3 = 'def'
s4 = s2 + 'c'
print(s1,s4)
print(s1 == s4) #같은 모양인가?
print(s1 is s4) #같은 메모리 위치인가?
print(s1 is 'abc')

답은 이렇게나옴

abc abc
True
False
True

--------------------------------------------


♡ 문자열 비교함수를 만들어보자
• 문자열이 같으면 0 리턴
• s1이 s2보다 사전 순서상 앞서면 -1 리턴
• s1이 s2보다 사전 순서상 나중이면 1 리턴

def my_strcmp(s1, s2):
	if s1<s2:
		return -1
	elif s1>s2:
		return 1
	else:
		return 0



>>>>>>>>>실습
s1 = 'ab'
s2 = 'ab'
s3 = 'ac'
s4 = 'AC'
s5 = 'abc'
s6 = '1ab'

print(s1 == s2)
print(s1 < s2)
print(s1 < s3)
print(s3 < s4)
print(ord('a'), ord('A'))
print(s1 < s5)
print(s4 < s6)
print('A' < '@')
print('ABC' < '@')

그럼 답 이렇게 나옴
True
False
True
False
97 65
True
False 		#숫자, 대문자, 소문자 순
False
False

------------------------


문자열 숫자를 정수로 변환하기

♡ c 언어에서는 atoi()함수를 제공한다. 역 함수로는 itoa()가 있다.

♡ java에서는 숫자 클래스의 parse 메소드를 제공한다.
• 예 : Inetger.parselnt(String)
• 역함수로는 toString( ) 메소드를 제공한다.

○파이썬에서는 숫자와 문자변환 함수를 제공한다.
ex) int("123"), float("3.14"), str(123), repr(123), int('A', 16)


실습>>>>>>>>
a = 'F'
b = int(a,16)
c = '1001'
d = int(c,2)
print(b)
print(d)

답,,,,
15
9
-------------------------------------------------

♡ int()와 같은 atoi()함수 만들기

s ='123'
(*앞자리부터 떼온다.
숫자 123으로 만들고싶으면 ,,,
i=0

a = atoi(s)
print(a + 1)

<코드>

def atoi(s):
	i = 0
	for x in s:
		i = i*10 + ord(x)-ord('0')
return i


--------------------------------
N = int(input())
txt = input()

for j in range(8-N+1):      #회문을 확인하는 구간의 첫 글자 인덱스
    for k in range(N//2):   #회문의 길이 절반만큼 비교
        if txt[j+k] != txt[j+N-1-k]:
            break       #비교 글자 다르면 현재 구간 중지
                        #for 문이 break에 걸리지 않고 for 종료, 회문이면
        else:
            total += 1
print(total)

------------------------------------

SWEA 2001. 파리퇴치
1954
2805
1244
1974
1210

if에 대한 고찰
continue, ,, else
----------------------------------------------------------------------
ladder 문제


#방향은세가지



1.위
	ㄱ.옆
	ㄴ.위


2. 좌
	ㄱ.우;
	ㄴ.위(x


T = 10

# 0: 상, 1:좌, 2: 우

dr = [-1, 0, 0]
dc = [0, -1, 1]
# 현재 위 일 땐 좌>우>상 순으로 탐색해라
search_dir = [[1,2,0], [0,1], [0,2]]

for _ in range(1, T+1):
    dir = 0
    r = 99
    c = -1

    tc = int(input())
    ladder = [list(map(int,input().splite())), for _ in range(100)]
    c = ladder[99].index(2)

    while r > 0:
        # 어디로 이동할건데?
        
        for i in range(len(search_dir[dir])):
            next_dir = search_dir[dir][i]
            next_r = r+dr[next_dir]
            next_c = c+dr[next_dir]
            
           
            #인덱스 이내
            if 0 <= next_r and 0 <= next_c < 100 and ladder[next_c] == 1:
                dir = next_r
                r = next_c
                break

   print(f'#{tc} {}')         

----------------------------------------------------------------------




파리채 시작점 n,n
돌면서총합구하기
m,m
















